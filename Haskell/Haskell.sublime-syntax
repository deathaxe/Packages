%YAML 1.2
---
# https://www.haskell.org/onlinereport/haskell2010
# https://www.sublimetext.com/docs/syntax.html
name: Haskell
scope: source.haskell
version: 2

file_extensions:
  - hs

###############################################################################

variables:
  # Comments
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-170002.3
  no_comment_ahead: '(?!{{comment_begin}})'
  comment_ahead: '(?={{comment_begin}})'
  comment_begin: '--+(?:{{comment_first_char}}|$)'
  comment_first_char: '[ \t\w"''(),;\[\]`{}]'

  # In case this regex seems overly general,
  # note that Haskell permits the definition of new operators
  # which can be nearly any string of punctuation characters,
  # such as $%^&*.
  operator_char: '[*|!%&$@#?~+:\-.=</>\\]'
  operator_infix: '{{operator_char}}+'
  operator_parens: '(?:{{no_comment_ahead}}{{operator_infix}}|,+)'

  # Identifiers
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
  con_id: (?:[[:upper:]][\w']*)
  var_id: (?:(?!{{reserved_id}})[[:lower:]][\w']*)
  reserved_id: |-
    (?x:
      case | class | data | default | deriving | do | else | foreign | if
    | import | in | infix | infixl | infixr | instance | let | module | newtype
    | of | then | type | where | _
    ){{break}}
  break: (?![\w'])

  # Escaped Characters
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
  escape_chars: |-
    (?x:
      NUL | SOH | STX | ETX | EOT | ENQ | ACK | BEL | BS | HT | LF | VT | FF
    | CR | SO | SI | DLE | DC1 | DC2 | DC3 | DC4 | NAK | SYN | ETB | CAN | EM
    | SUB | ESC | FS | GS | RS | US | SP | DEL
    | [abfnrtv\\\"'\&]
    )
  escape_sequence: |-
    (?x:
        (\\{{escape_chars}}) # Escapes
      | (\\[0-9]+)           # Decimal Escapes
      | (\\o[0-7]+)          # Octal Escapes
      | (\\x[0-9A-Fa-f]+)    # Hexadecimal Escapes
      | (\^[A-Z@\[\]\\\^_])  # Control Chars
    )

  class_names: |-
    (?x:
      Monad | Monadoid | Functor | Applicative | Foldableble | Traversable | Eq
    | Ord | Read | Show | Num | Fractional | Rational | Enum | Bounded | Real
    | RealFrac | RealFloat | Integral | Floating
    ){{break}}

  function_names: |-
    (?x:
      abs | acos | acosh | all | and | any | appendFile | asTypeOf | asin
    | asinh | atan | atan2 | atanh | break | ceiling | compare | concat
    | concatMap | const | cos | cosh | curry | cycle | decodeFloat | div
    | divMod | drop | dropWhile | either | elem | encodeFloat | enumFrom
    | enumFromThen | enumFromThenTo | enumFromTo | error | errorWithoutStackTrace
    | even | exp | exponent | fail | filter | flip | floatDigits | floatRadix
    | floatRange | floor | fmap | foldMap | foldl | foldl1 | foldr | foldr1
    | fromEnum | fromInteger | fromIntegral | fromRational | fst | gcd | getChar
    | getContents | getLine | head | id | init | interact | ioError
    | isDenormalized | isIEEE | isInfinite | isNaN | isNegativeZero | iterate
    | last | lcm | length | lex | lines | log | logBase | lookup | map | mapM
    | mapM_ | mappend | max | maxBound | maximum | maybe | mconcat | mempty
    | min | minBound | minimum | mod | negate | not | notElem | null | odd | or
    | otherwise | pi | pred | print | product | properFraction | pure | putChar
    | putStr | putStrLn | quot | quotRem | read | readFile | readIO | readList
    | readLn | readParen | reads | readsPrec | realToFrac | recip | rem | repeat
    | replicate | return | reverse | round | scaleFloat | scanl | scanl1 | scanr
    | scanr1 | seq | sequence | sequenceA | sequence_ | show | showChar
    | showList | showParen | showString | shows | showsPrec | significand
    | signum | sin | sinh | snd | span | splitAt | sqrt | subtract | succ | sum
    | tail | take | takeWhile | tan | tanh | toEnum | toInteger | toRational
    | traverse | truncate | uncurry | undefined | unlines | until | unwords
    | unzip | unzip3 | userError | words | writeFile | zip | zip3 | zipWith
    | zipWith3
    ){{break}}

  # https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pragmas
  pragma_keys: |-
    (?x:
      LANGUAGE | OPTIONS_GHC | OPTIONS_HADDOCK | INCLUDE | WARNING | DEPRECATED
    | MINIMAL | UNPACK | NOUNPACK | SOURCE | OVERLAPPING | OVERLAPPABLE
    | OVERLAPS | INCOHERENT | INLINE | NOINLINE | INLINABLE | CONLIKE | LINE
    | RULES | SPECIALIZE | SPECIALISE
    ){{break}}

###############################################################################

contexts:
  prototype:
    - include: comments
    - include: preprocessor-pragmas
    - include: preprocessor-directives

  main:
    - include: statements
    - include: expressions

  statements:
    - include: blocks
    - include: functions
    - include: instances
    - include: classes
    - include: imports
    - include: modules
    - include: statement-terminators

  expressions:
    - include: keywords
    - include: operators
    - include: literal-chars
    - include: literal-strings
    - include: literal-numbers
    - include: literal-units
    - include: splice
    - include: groups
    - include: lists
    - include: ident-builtin-functions
    - include: ident-constants
    - include: ident-variables

  type-signatures:
    - include: arrow-operators
    - include: big-arrow-operators
    - include: ident-generic-types
    - include: ident-types
    - include: literal-units

###[ COMMENTS ]################################################################

  comments:
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-170002.3
    - include: line-comments
    - include: block-comments

  block-comments:
    - match: \{-(?!#)
      scope: punctuation.definition.comment.begin.haskell
      push: block-comment-body

  block-comment-body:
    - meta_scope: comment.block.haskell
    - match: -\}
      scope: punctuation.definition.comment.end.haskell
      pop: 1
    - match: \{-#
      push: block-comment-nested-body
    - include: block-comments

  block-comment-nested-body:
    - match: -\}
      pop: 1
    - include: block-comments

  line-comments:
    - match: (--+)(?:{{comment_first_char}}.*)?$\n?
      scope: comment.line.double-dash.haskell
      captures:
        1: punctuation.definition.comment.haskell

###[ PREPROCESSOR ]############################################################

  preprocessor-directives:
    # In addition to Haskell's "native" syntax,
    # GHC permits the C preprocessor to be run on a source file.
    - match: ^\s*((#)\s*\w+)
      scope: meta.preprocessor.c
      captures:
        1: keyword.directive.other.c
        2: punctuation.definition.preprocessor.c

  preprocessor-pragmas:
    - match: \{-#
      push: preprocessor-pragma-body

  preprocessor-pragma-body:
    - meta_scope: meta.preprocessor.haskell
    - match: '#-\}'
      pop: 1
    - match: '{{pragma_keys}}'
      scope: keyword.directive.other.haskell

###[ MODULE DECLARATIONS ]#####################################################

  modules:
    - match: module{{break}}
      scope: keyword.declaration.namespace.haskell
      push: module-body

  module-body:
    - meta_scope: meta.declaration.module.haskell
    - match: where{{break}}
      scope: keyword.control.context.haskell
      pop: 1
    - match: ({{con_id}})(\.)
      captures:
        1: variable.namespace.haskell
        2: punctuation.accessor.dot.haskell
    - match: '{{con_id}}'
      scope: entity.name.namespace.haskell
    - include: symbols
    - match: (?=\S)
      pop: 1

###[ IMPORT DECLARATIONS ]#####################################################

  imports:
    - match: import{{break}}
      scope: keyword.declaration.import.haskell
      push: import-body

  import-body:
    - meta_scope: meta.import.haskell
    - match: (?:qualified|as|hiding){{break}}
      scope: keyword.declaration.import.haskell
    - match: ({{con_id}})\s*(?:(\.)|(?=\(|as{{break}}))
      captures:
        1: variable.namespace.haskell
        2: punctuation.accessor.dot.haskell
    - match: '{{con_id}}'
      scope: entity.name.namespace.haskell
    - include: symbols
    - match: (?=\S)
      pop: 1

###[ SYMBOL DECLARATIONS ]#####################################################

  symbols:
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      push: symbol-body

  symbol-body:
    - meta_scope: meta.sequence.symbols.haskell
    - match: \)
      scope: punctuation.section.sequence.end.haskell
      pop: 1
    - include: ident-builtin-functions
    - include: ident-functions
    - include: ident-types
    - include: sequence-separators
    - include: infix-parens-operators
    - match: \({{no_comment_ahead}}.*?\)
      comment: So named because I don't know what to call this.
      scope: meta.other.unknown.haskell

###[ CLASS DECLARATIONS ]######################################################

  classes:
    - match: class{{break}}
      scope: keyword.declaration.class.haskell
      push: class-body
    - match: (deriving|via)\s*\(
      captures:
        1: keyword.other.haskell
      push: inherited-body

  class-body:
    - meta_scope: meta.declaration.class.haskell
    - match: where{{break}}
      scope: keyword.control.context.haskell
      pop: 1
    - match: '{{class_names}}'
      scope: support.class.prelude.haskell
    - include: ident-inherited-classs
    - include: ident-generic-types
    - include: big-arrow-operators

  inherited-body:
    - meta_scope: meta.deriving.haskell
    - match: \)
      pop: 1
    - include: ident-inherited-classs

###[ INSTANCE DECLARATIONS ]###################################################

  instances:
    - match: instance{{break}}
      scope: keyword.declaration.haskell
      push: instance-body

  instance-body:
    - meta_scope: meta.declaration.instance.haskell
    - match: where{{break}}|$
      scope: keyword.control.context.haskell
      pop: 1
    - include: type-signatures

###[ FUNCTION DECLARATIONS ]###################################################

  functions:
    - match: '^(\s*)({{var_id}}|\(({{operator_parens}})\))\s*(::|∷)'
      captures:
        2: entity.name.function.haskell
        3: keyword.operator.infix.haskell
        4: keyword.other.double-colon.haskell
      push: function-body

  function-body:
    - meta_scope: meta.function.type-declaration.haskell
    - match: ^(?!\s*(?:--|{-|$)|\1\s)
      pop: 1
    - include: type-signatures

###[ BLOCKS ]##################################################################

  blocks:
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
    - match: \{
      scope: punctuation.section.block.begin.haskell
      push: block-body

  block-body:
    - meta_scope: meta.block.haskell
    - match: \}
      scope: punctuation.section.block.end.haskell
      pop: 1
    - include: statements

###[ GROUPS AND LISTS ]########################################################

  groups:
    - match: \(
      scope: punctuation.section.group.begin.haskell
      push: group-body

  group-body:
    - meta_scope: meta.group.haskell
    - match: \)
      scope: punctuation.section.group.end.haskell
      pop: 1
    - include: expressions

  lists:
    - match: \[\]
      scope: constant.language.empty-list.haskell
    - match: \[
      scope: punctuation.section.sequence.begin.haskell
      push: list-body

  list-body:
    - meta_scope: meta.sequence.haskell
    - match: \]
      scope: punctuation.section.sequence.end.haskell
      pop: 1
    - include: expressions

###[ LITERALS ]################################################################

  literal-units:
    - match: \(\)
      scope: constant.language.unit.haskell

  literal-numbers:
    - match: (\d+)(?:(\.)(\d+)([eE][-+]?\d+)?|([eE][-+]?\d+)){{break}}
      scope: meta.number.float.decimal.haskell
      captures:
        1: constant.numeric.value.haskell
        2: punctuation.separator.decimal.haskell
        3: constant.numeric.value.haskell
        4: constant.numeric.value.exponent.haskell
        5: constant.numeric.value.exponent.haskell
    - match: (0[oO])([0-7]+){{break}}
      scope: meta.number.integer.octal.haskell
      captures:
        1: constant.numeric.base.haskell
        2: constant.numeric.value.haskell
    - match: (0[xX])(\h+){{break}}
      scope: meta.number.integer.hexadecimal.haskell
      captures:
        1: constant.numeric.base.haskell
        2: constant.numeric.value.haskell
    - match: \d+{{break}}
      scope: meta.number.integer.decimal.haskell constant.numeric.value.haskell

  literal-chars:
    - match: |-
        (?x)
        (')
        (?:
          ([\ -\[\]-~])          # Basic Char
          | {{escape_sequence}}  # Escapes
        )
        ([^']*?)
        (?:(')|{{comment_ahead}})
      scope: meta.string.haskell string.quoted.single.haskell
      captures:
        1: punctuation.definition.string.begin.haskell
        2: constant.character.literal.haskell
        3: constant.character.escape.haskell
        4: constant.character.escape.decimal.haskell
        5: constant.character.escape.octal.haskell
        6: constant.character.escape.hexadecimal.haskell
        7: constant.character.escape.control.haskell
        8: invalid.illegal.expected-closing-quotation.haskell
        9: punctuation.definition.string.end.haskell

  literal-strings:
    - match: \"
      scope: punctuation.definition.string.begin.haskell
      push: literal-string-body

  literal-string-body:
    - meta_include_prototype: false
    - meta_scope: meta.string.haskell string.quoted.double.haskell
    - match: \"|$|{{comment_ahead}}
      scope: punctuation.definition.string.end.haskell
      pop: 1
    - match: '{{escape_sequence}}'
      captures:
        1: constant.character.escape.haskell
        2: constant.character.escape.decimal.haskell
        3: constant.character.escape.octal.haskell
        4: constant.character.escape.hexadecimal.haskell
        5: constant.character.escape.control.haskell

###[ KEYWORDS AND OPERATORS ]##################################################

  keywords:
    - match: (?:do|in){{break}}
      scope: keyword.control.context.haskell
    - match: (?:newtype|type){{break}}
      scope: keyword.declaration.type.haskell
    - match: (?:data){{break}}
      scope: keyword.declaration.data.haskell
    - match: (?:deriving){{break}}
      scope: keyword.declaration.data.haskell
    - match: (?:case|of){{break}}
      scope: keyword.control.conditional.select.haskell  # the construct is commonly called "select"
    - match: (?:let|where){{break}}
      scope: keyword.declaration.variable.haskell
    - match: (?:return){{break}}
      scope: keyword.control.flow.return.haskell
    - match: (?:default|otherwise){{break}}
      scope: keyword.other.haskell
    - match: (?:if){{break}}
      scope: keyword.control.conditional.if.haskell
    - match: (?:then){{break}}
      scope: keyword.control.conditional.then.haskell
    - match: (?:else){{break}}
      scope: keyword.control.conditional.else.haskell

  operators:
    - match: (`)[ \w'.]+(`)
      # Haskell allows any ordinary function application (elem 4 [1..10])
      # to be rewritten as an infix expression (4 `elem` [1..10])."
      scope: keyword.operator.function.infix.haskell
      captures:
        1: punctuation.definition.function.begin.haskell
        2: punctuation.definition.function.end.haskell
    - match: (`)[^`]*?(?:(`)|{{comment_ahead}})
      scope: invalid.illegal.operator.haskell
    - match: infix[lr]?{{break}}
      scope: keyword.operator.haskell
    - match: '{{operator_infix}}'
      scope: keyword.operator.haskell
    - include: infix-parens-operators
    - include: sequence-separators

  arrow-operators:
    - match: (?:->|→)
      scope: keyword.other.arrow.haskell

  big-arrow-operators:
    - match: (?:=>|⇒)
      scope: keyword.other.big-arrow.haskell

  infix-parens-operators:
    - match: \(({{operator_parens}})\)
      scope: variable.function.infix.haskell
      captures:
        1: keyword.operator.haskell

  statement-terminators:
    # Depending on layout, semicolon may be needed to terminate statements.
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
    - match: ';'
      scope: punctuation.terminator.statement.haskell

  sequence-separators:
    - match: ','
      scope: punctuation.separator.sequence.haskell

  splice:
    - match: '\[(?:|e|d|t|p)\|'
      comment: Points out splices in ast quotes
      scope: keyword.other.quasibracket.haskell
      push:
        - meta_scope: meta.other.quasiquote.haskell
        - match: '(.*)(\|\])'
          captures:
            1: string.quasiquoted.haskell
            2: keyword.other.quasibracket.haskell
          pop: 1
        - match: \$\(
          scope: keyword.other.splice.haskell
        - match: \$
          scope: string.quasiquoted.haskell
        - match: '[^$]*'
          scope: string.quasiquoted.haskell
    - match: \$\(
      comment: Highlight the beginning of a splice.
      scope: keyword.other.splice.haskell
    - match: '\[[\w'']*\|'
      scope: keyword.other.quasibracket.haskell
      push:
        - meta_scope: meta.other.quasiquote.haskell
        - match: '(.*)(\|\])'
          captures:
            1: string.quasiquoted.haskell
            2: keyword.other.quasibracket.haskell
          pop: 1
        - match: .*
          scope: string.quasiquoted.haskell

###[ IDENTIFIERS ]#############################################################

  ident-inherited-classs:
    - match: '{{con_id}}'
      scope: entity.other.inherited-class.haskell

  ident-generic-types:
    - match: '{{var_id}}'
      scope: variable.other.generic-type.haskell

  ident-types:
    - match: '{{con_id}}'
      scope: storage.type.haskell

  ident-constants:
    - match: '{{con_id}}'
      scope: constant.other.haskell

  ident-builtin-functions:
    - match: '{{function_names}}'
      scope: support.function.prelude.haskell

  ident-functions:
    - match: '{{var_id}}'
      scope: variable.function.haskell

  ident-variables:
    - match: '{{var_id}}'
      scope: meta.name.haskell
