%YAML 1.2
---
# https://www.haskell.org/onlinereport/haskell2010
# https://www.sublimetext.com/docs/syntax.html
name: Haskell
scope: source.haskell
version: 2

file_extensions:
  - hs
  - hs-boot
  - hsig

###############################################################################

variables:
  # 2.2 Lexical Program Structure
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-160002.2
  special: '[(),;\[\]`{}]'
  symbol: '[\p{S}\p{P}&&[^_"''{{special}}]]'
  ascii_symbol: '[!#$%&⋆+./<=>?@\\\^|\-~:]'
  unicode_symbol: '[[:punct:]&&[^:ascii:]]'

  # 2.3 Comments
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-170002.3
  no_comment_ahead: '(?!{{comment_begin}})'
  comment_ahead: '(?={{comment_begin}})'
  comment_begin: '--+(?:{{comment_first_char}}|$)'
  comment_first_char: '[\s\w"''{{special}}]'

  # 2.4 Identifiers and Operators
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
  con_id: (?:[[:upper:]][\w']*)
  var_id: (?:(?!{{reserved_id}})[[:lower:]_][\w']*)
  reserved_id: |-
    (?x:
      _ | case | class | data | default | deriving | do | else | family | forall
    | foreign | if | import | in | infix | infixl | infixr | instance | let | mdo
    | module | newtype | of | proc | rec | signature | then | type | via | where
    ){{break}}
  break: (?![\w'])

  # In case this regex seems overly general, note that Haskell permits
  # the definition of new operators which can be nearly any string
  # of punctuation characters, such as $%^&*.
  operator_symbol: (?:{{symbol}}+)
  operator_parens: (?:{{no_comment_ahead}}{{operator_symbol}})

  operator_double_colon: (?:::|∷)
  operator_big_arrow: (?:=>|⇒)
  operator_left_arrow: (?:<-|←)
  operator_right_arrow: (?:->|→)

  consym: (?:[:]{{varsym}})
  varsym: (?:[{{symbol}}&&[^:]]{{symbol}}*)

  # 2.6 Character and String Literals
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
  escape_chars: |-
    (?x:
      NUL | SOH | STX | ETX | EOT | ENQ | ACK | BEL | BS | HT | LF | VT | FF
    | CR | SO | SI | DLE | DC1 | DC2 | DC3 | DC4 | NAK | SYN | ETB | CAN | EM
    | SUB | ESC | FS | GS | RS | US | SP | DEL
    | [abfnrtv\\\"'\&]
    )
  escape_sequence: |-
    (?x:
        (\\{{escape_chars}}) # Escapes
      | (\\[0-9]+)           # Decimal Escapes
      | (\\o[0-7]+)          # Octal Escapes
      | (\\x[0-9A-Fa-f]+)    # Hexadecimal Escapes
      | (\^[A-Z@\[\]\\\^_])  # Control Chars
    )

  builtin_classes: |-
    (?x:
    # 9 Standard Prelude
      Applicative | Bounded | Enum | Eq | Floating | Foldableble | Fractional
    | Functor | Integral | Monad | Monadoid | Num | Ord | Rational | Read
    | Real | RealFloat | RealFrac | Show | Traversable
    ){{break}}

  builtin_constants: |-
    (?x: Just | Nothing | Left | Right | True | False | LT | EQ | GT ){{break}}

  builtin_types: |-
    (?x:
    # 9 Standard Prelude
      Bool | Char | Double | Either | FilePath | Float | Int | Integer | IO
    | IOError | Maybe | Ordering | ReadS | ShowS | String | Word
    # 24 Foreign
    # https://www.haskell.org/onlinereport/haskell2010/haskellch24.html#x32-26200024
    | Int8 | Int16 | Int32 | Int64 | Word8 | Word16 | Word32 | Word64
    | Ptr | FunPtr | StablePtr
    ){{break}}

  builtin_functions: |-
    (?x:
      abs | acos | acosh | all | and | any | appendFile | asTypeOf | asin
    | asinh | atan | atan2 | atanh | break | ceiling | compare | concat
    | concatMap | const | cos | cosh | curry | cycle | decodeFloat | div
    | divMod | drop | dropWhile | either | elem | encodeFloat | enumFrom
    | enumFromThen | enumFromThenTo | enumFromTo | error | errorWithoutStackTrace
    | even | exp | exponent | fail | filter | flip | floatDigits | floatRadix
    | floatRange | floor | fmap | foldMap | foldl | foldl1 | foldr | foldr1
    | fromEnum | fromInteger | fromIntegral | fromRational | fst | gcd | getChar
    | getContents | getLine | head | id | init | interact | ioError
    | isDenormalized | isIEEE | isInfinite | isNaN | isNegativeZero | iterate
    | last | lcm | length | lex | lines | log | logBase | lookup | map | mapM
    | mapM_ | mappend | max | maxBound | maximum | maybe | mconcat | mempty
    | min | minBound | minimum | mod | negate | not | notElem | null | odd | or
    | otherwise | pi | pred | print | product | properFraction | pure | putChar
    | putStr | putStrLn | quot | quotRem | read | readFile | readIO | readList
    | readLn | readParen | reads | readsPrec | realToFrac | recip | rem | repeat
    | replicate | return | reverse | round | scaleFloat | scanl | scanl1 | scanr
    | scanr1 | seq | sequence | sequenceA | sequence_ | show | showChar
    | showList | showParen | showString | shows | showsPrec | significand
    | signum | sin | sinh | snd | span | splitAt | sqrt | subtract | succ | sum
    | tail | take | takeWhile | tan | tanh | toEnum | toInteger | toRational
    | traverse | truncate | uncurry | undefined | unlines | until | unwords
    | unzip | unzip3 | userError | words | writeFile | zip | zip3 | zipWith
    | zipWith3
    ){{break}}

  # https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pragmas
  pragma_keys: |-
    (?x:
      LANGUAGE | OPTIONS_GHC | OPTIONS_HADDOCK | INCLUDE | WARNING | DEPRECATED
    | MINIMAL | UNPACK | NOUNPACK | SOURCE | OVERLAPPING | OVERLAPPABLE
    | OVERLAPS | INCOHERENT | INLINE | NOINLINE | INLINABLE | CONLIKE | LINE
    | RULES | SPECIALIZE | SPECIALISE
    ){{break}}

  # https://wiki.haskell.org/Language_extensions
  # https://github.com/JustusAdam/language-haskell
  pragma_deprecated_constants: |-
    (?:No)?(?x:
      AutoDeriveTypeable | DatatypeContexts | DoRec | IncoherentInstances
    | MonadFailDesugaring | MonoPatBinds | NullaryTypeClasses
    | OverlappingInstances | PatternSignatures | RecordPuns | RelaxedPolyRec
    ){{break}}

  # https://wiki.haskell.org/Language_extensions
  # https://github.com/JustusAdam/language-haskell
  pragma_extension_constants: |-
    (?:No)?(?x:
      AllowAmbiguousTypes | AlternativeLayoutRule
    | AlternativeLayoutRuleTransitional | Arrows | BangPatterns | BinaryLiterals
    | CApiFFI | CPP | CUSKs | ConstrainedClassMethods | ConstraintKinds
    | DataKinds | DefaultSignatures | DeriveAnyClass | DeriveDataTypeable
    | DeriveFoldable | DeriveFunctor | DeriveGeneric | DeriveLift
    | DeriveTraversable | DerivingStrategies | DerivingVia
    | DisambiguateRecordFields | DoAndIfThenElse | BlockArguments
    | DuplicateRecordFields | EmptyCase | EmptyDataDecls | EmptyDataDeriving
    | ExistentialQuantification | ExplicitForAll | ExplicitNamespaces
    | ExtendedDefaultRules | FlexibleContexts | FlexibleInstances
    | ForeignFunctionInterface | FunctionalDependencies | GADTSyntax | GADTs
    | GHCForeignImportPrim | Generali(?:s | z)edNewtypeDeriving | ImplicitParams
    | ImplicitPrelude | ImportQualifiedPost | ImpredicativeTypes
    | TypeFamilyDependencies | InstanceSigs | ApplicativeDo | InterruptibleFFI
    | JavaScriptFFI | KindSignatures | LambdaCase | LiberalTypeSynonyms | MagicHash
    | MonadComprehensions | MonoLocalBinds | MonomorphismRestriction
    | MultiParamTypeClasses | MultiWayIf | NumericUnderscores | NPlusKPatterns
    | NamedFieldPuns | NamedWildCards | NegativeLiterals | HexFloatLiterals
    | NondecreasingIndentation | NumDecimals | OverloadedLabels | OverloadedLists
    | OverloadedStrings | PackageImports | ParallelArrays | ParallelListComp
    | PartialTypeSignatures | PatternGuards | PatternSynonyms | PolyKinds
    | PolymorphicComponents | QuantifiedConstraints | PostfixOperators
    | QuasiQuotes | Rank2Types | RankNTypes | RebindableSyntax | RecordWildCards
    | RecursiveDo | RelaxedLayout | RoleAnnotations | ScopedTypeVariables
    | StandaloneDeriving | StarIsType | StaticPointers | Strict | StrictData
    | TemplateHaskell | TemplateHaskellQuotes | StandaloneKindSignatures
    | TraditionalRecordSyntax | TransformListComp | TupleSections
    | TypeApplications | TypeInType | TypeFamilies | TypeOperators
    | TypeSynonymInstances | UnboxedTuples | UnboxedSums
    | UndecidableInstances | UndecidableSuperClasses | UnicodeSyntax
    | UnliftedFFITypes | UnliftedNewtypes | ViewPatterns
    ){{break}}

###############################################################################

contexts:
  prototype:
    - include: comments
    - include: preprocessor-pragmas
    - include: preprocessor-directives

  main:
    - include: modules
    - include: declarations
    - include: statements
    - include: expressions

  declarations:
    - include: classes
    - include: datas
    - include: foreigns
    - include: imports
    - include: instances
    - include: newtypes
    - include: types
    - include: functions

  statements:
    - include: blocks
    - include: defaults
    - include: deriving
    - include: statement-terminators

  expressions:
    - include: literal-chars
    - include: literal-strings
    - include: literal-numbers
    - include: type-signatures
    - include: operators
    - include: splice
    - include: groups-or-tuples
    - include: lists
    - include: keywords
    - include: ident-anonymous
    - include: ident-namespaces
    - include: ident-builtin-functions
    - include: ident-types
    - include: ident-variables

###[ COMMENTS ]################################################################

  comments:
    # 2.3 Comments
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-170002.3
    - include: line-comments
    - include: block-comments

  block-comments:
    - match: \{-(?!#)
      scope: punctuation.definition.comment.begin.haskell
      push: block-comment-body

  block-comment-body:
    - meta_include_prototype: false
    - meta_scope: comment.block.haskell
    - match: -\}
      scope: punctuation.definition.comment.end.haskell
      pop: 1
    - match: \{-#
      push: block-comment-nested-body
    - include: block-comments

  block-comment-nested-body:
    - meta_include_prototype: false
    - match: -\}
      pop: 1
    - include: block-comments

  line-comments:
    - match: (--+)(?:{{comment_first_char}}.*)?$\n?
      scope: comment.line.double-dash.haskell
      captures:
        1: punctuation.definition.comment.haskell

###[ PREPROCESSOR ]############################################################

  preprocessor-directives:
    # In addition to Haskell's "native" syntax,
    # GHC permits the C preprocessor to be run on a source file.
    - match: ^\s*((#)\s*\w+)
      scope: meta.preprocessor.c
      captures:
        1: keyword.directive.other.c
        2: punctuation.definition.preprocessor.c

  preprocessor-pragmas:
    # 12 Compiler Pragmas
    # https://www.haskell.org/onlinereport/haskell2010/haskellch12.html#x19-18800012
    - match: \{-#
      scope: punctuation.section.preprocessor.begin.haskell
      push: preprocessor-pragma-body

  preprocessor-pragma-body:
    - meta_include_prototype: false
    - meta_scope: meta.preprocessor.pragma.directive.haskell
    - include: comments
    # known directives
    - match: LANGUAGE{{break}}
      scope: keyword.directive.language.haskell
      set: preprocessor-pragma-language-value
    - match: '{{pragma_keys}}'
      scope: keyword.directive.builtin.haskell
      set: preprocessor-pragma-other-value
    # maybe incomplete directive
    # maintain meta scope to support completions
    - match: \p{Lu}+|(?=\S)
      set: preprocessor-pragma-other-value

  preprocessor-pragma-language-value:
    - meta_include_prototype: false
    - meta_content_scope: meta.preprocessor.pragma.value.language.haskell
    - include: preprocessor-pragma-common
    - match: '{{pragma_extension_constants}}'
      scope: constant.language.extension.haskell
    - match: '{{pragma_deprecated_constants}}'
      scope: constant.language.extension.haskell invalid.deprecated.haskell

  preprocessor-pragma-other-value:
    - meta_include_prototype: false
    - meta_content_scope: meta.preprocessor.pragma.value.other.haskell
    - include: preprocessor-pragma-common
    - include: constructor-separators
    - include: literal-numbers
    - include: literal-strings
    - match: (-*)[-\w]+
      scope: constant.other.pragma.haskell
      captures:
        1: punctuation.definition.constant.haskell

  preprocessor-pragma-common:
    - match: '#-\}'
      scope:
        meta.preprocessor.pragma.value.haskell
        punctuation.section.preprocessor.end.haskell
      pop: 1
    - include: comments
    - include: sequence-separators

###[ MODULE DECLARATIONS ]#####################################################

  modules:
    # 5.1 Module Structure
    # https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1
    - match: module{{break}}
      scope: keyword.declaration.namespace.haskell
      push:
        - module-block
        - module-meta
        - module-name
    # https://wiki.haskell.org/Module_signature
    - match: signature{{break}}
      scope: keyword.declaration.namespace.haskell
      push:
        - module-block
        - signature-meta
        - module-name

  module-meta:
    - meta_include_prototype: false
    - meta_scope: meta.declaration.module.haskell
    - include: immediatelly-pop

  signature-meta:
    - meta_include_prototype: false
    - meta_scope: meta.declaration.signature.haskell
    - include: immediatelly-pop

  module-name:
    - include: ident-namespaces
    - include: ident-modules
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      set: module-exports-body
    - include: else-pop

  module-exports-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - include: range-tuples
    - include: infix-parens-operators
    - include: sequence-separators
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      push: module-exports-body
    - match: module{{break}}
      scope: keyword.declaration.namespace.haskell
    - include: ident-functions
    - include: ident-namespaces
    - include: ident-types
    - include: else-pop

  module-block:
    # The module body may be wrapped into braces, which still needs to be
    # handled as top-level block containing top-level declarations.
    - match: \{
      scope: punctuation.section.block.begin.haskell
      set: module-block-body
    - match: where{{break}}
      scope: keyword.control.context.haskell
    - include: else-pop

  module-block-body:
    - meta_scope: meta.block.haskell
    - include: block-end
    - include: declarations
    - include: statements
    - include: expressions

###[ IMPORT DECLARATIONS ]#####################################################

  imports:
    # 5.3 Import Declarations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1010005.3
    - match: import{{break}}
      scope: keyword.declaration.import.haskell
      push:
        - import-meta
        - import-body

  import-meta:
    - meta_include_prototype: false
    - meta_scope: meta.import.haskell
    - include: immediatelly-pop

  import-body:
    - match: (?:qualified|as|hiding){{break}}
      scope: storage.modifier.import.haskell
    - include: ident-namespaces
    - include: ident-modules
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      set: import-tuple-body
    - include: else-pop

  import-tuple-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - include: range-tuples
    - include: infix-parens-operators
    - include: sequence-separators
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      push: import-tuple-body
    - match: \.
      scope: invalid.illegal.accessor.haskell
    - match: module{{break}}
      scope: invalid.illegal.unexpected-keyword.haskell
    - include: ident-functions
    - include: ident-types
    - include: else-pop

###[ FOREIGN DECLARATIONS ]####################################################

  foreigns:
    # 8.4 Foreign Declarations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1490008
    - match: foreign{{break}}
      scope: storage.modifier.foreign.haskell
      branch_point: foreign
      branch:
        - foreign-import
        - foreign-export

  foreign-import:
    # 8.4.3 Import Declarations
    - meta_scope: meta.declaration.foreign.import.haskell
    - match: export{{break}}
      fail: foreign
    - match: import{{break}}
      scope: keyword.declaration.import.haskell
    - match: (?:unsafe|safe){{break}}
      scope: storage.modifier.import.haskell
    - include: foreign-common

  foreign-export:
    # 8.4.4 Export Declarations
    - meta_scope: meta.declaration.foreign.export.haskell
    - match: export{{break}}
      scope: keyword.declaration.export.haskell
    - match: (?:unsafe|safe){{break}}
      scope: invalid.illegal.unexpected-keyword.haskell
    - include: foreign-common

  foreign-common:
    - include: literal-strings
    - include: infix-parens-operators
    - match: (?:ccall|cplusplus|dotnet|jvm|stdcall){{break}}
      scope: constant.language.convention.haskell
    - match: '{{var_id}}'
      scope: entity.name.function.haskell
    - include: else-pop

###[ CLASS DECLARATIONS ]######################################################

  classes:
    # 4.3.1 Class Declarations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
    - match: class{{break}}
      scope:
        meta.declaration.class.haskell
        keyword.declaration.class.haskell
      branch_point: classes
      branch:
        - class-context
        - class-signature

  class-else-fail:
    - match: (?=\S)
      fail: classes

  class-context:
    # The context specifies the superclasses
    - meta_content_scope: meta.declaration.class.context.haskell
    - match: '{{operator_big_arrow}}'
      scope:
        meta.declaration.class.haskell
        keyword.operator.big-arrow.haskell
      set: class-signature
    - include: class-context-decls
    - include: class-else-fail

  class-context-decls:
    - include: class-context-tuples
    - include: ident-anonymous
    - include: ident-namespaces
    - include: ident-types
    - include: ident-variables

  class-context-tuples:
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      push: class-context-tuple-body

  class-context-tuple-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - include: sequence-separators
    - include: class-context-decls
    - include: else-pop

  class-signature:
    - meta_content_scope: meta.declaration.class.signature.haskell
    - include: type-content
    - match: where{{break}}
      scope: keyword.control.context.haskell
      set: class-block
    - include: else-pop

  class-block:
    - match: \{
      scope: punctuation.section.block.begin.haskell
      set: class-block-body
    - match: ^(?!\s*(?:--|{-?|$))
      pop: 1

  class-block-body:
    - meta_scope: meta.block.haskell
    - include: block-end
    - include: functions
    - include: statements
    - include: expressions

###[ DATA DECLARATIONS ]#######################################################

  datas:
    # 4.2.1 Algebraic Datatype Declarations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-680004.2
    - match: data{{break}}
      scope:
        meta.declaration.data.haskell
        keyword.declaration.data.haskell
      push: data-body

  data-body:
    - meta_content_scope: meta.declaration.data.haskell
    - match: =
      scope: keyword.operator.haskell
      set: data-constructor
    # https://wiki.haskell.org/GHC/Type_families
    - match: (?:family|instance){{break}}
      scope: storage.modifier.family.haskell
    - include: type-signature-body

  data-constructor:
    - include: constructor-operators
    - include: constructor-separators
    - include: records
    - include: ident-types
    - include: else-pop

###[ DEFAULT DECLARATIONS ]####################################################

  defaults:
    # 4.3.4 Ambiguous Types, and Defaults for Overloaded Numeric Operations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
    - match: default{{break}}
      scope: storage.modifier.haskell
      push:
        - default-meta
        - default-body

  default-meta:
    - meta_include_prototype: false
    - meta_scope: meta.declaration.default.haskell
    - include: immediatelly-pop

  default-body:
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      set: type-tuple-body
    - include: else-pop

###[ DERIVING DECLARATIONS ]###################################################

  deriving:
    # 4.3.3 Derived Instances
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
    - match: (?:deriving|via){{break}}
      scope: storage.modifier.haskell
      push:
        - deriving-meta
        - deriving-body

  deriving-meta:
    - meta_include_prototype: false
    - meta_scope: meta.declaration.deriving.haskell
    - include: immediatelly-pop

  deriving-body:
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      set: deriving-tuple-body
    - include: ident-namespaces
    - include: ident-inherited-class
    - include: else-pop

  deriving-tuple-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - include: sequence-separators
    - include: ident-namespaces
    - include: ident-inherited-classes
    - include: else-pop

###[ INSTANCE DECLARATIONS ]###################################################

  instances:
    # 4.3.2 Instance Declarations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
    - match: instance{{break}}
      scope: keyword.declaration.instance.haskell
      push: instance-body

  instance-body:
    - meta_scope: meta.declaration.instance.haskell
    - include: type-signature-body

###[ FUNCTION DECLARATIONS ]###################################################

  functions:
    - match: (?={{var_id}}|\(\s*{{operator_parens}}\s*\))
      branch_point: functions
      branch:
        - variable-name
        - function-name

  function-name:
    - meta_content_scope: meta.function.identifier.haskell
    - match: '{{operator_double_colon}}'
      scope: keyword.operator.double-colon.haskell
      pop: 1
    - match: '{{var_id}}'
      scope: entity.name.function.haskell
    - match: \(\s*({{operator_parens}})\s*\)
      scope: entity.name.function.infix.haskell
      captures:
        1: keyword.operator.haskell
    - include: sequence-separators

  variable-name:
    - match: \(\s*({{operator_parens}})\s*\)
      scope: variable.function.infix.haskell
      captures:
        1: keyword.operator.haskell
      push: variable-name-end
    - match: '{{builtin_functions}}'
      scope: support.function.prelude.haskell
      push: variable-name-end
    - match: '{{var_id}}'
      scope: variable.other.haskell
      push: variable-name-end
    - include: sequence-separators
    - include: else-pop

  variable-name-end:
    - match: (?={{operator_double_colon}})
      fail: functions
    - match: (?=,)
      pop: 1
    - match: (?=\S)
      pop: 2

###[ NEWTYPE DECLARATIONS ]####################################################

  newtypes:
    - match: newtype{{break}}
      scope: keyword.declaration.newtype.haskell
      push: newtype-body

  newtype-body:
    - meta_scope: meta.declaration.newtype.haskell
    - match: ^(?!\s*(?:--|{-|$))
      pop: 1
    - match: =(?!>)
      scope: keyword.operator.haskell
    - include: big-arrow-operators
    - include: type-content
    - include: else-pop

###[ TYPE DECLARATIONS ]#######################################################

  types:
    - match: type{{break}}
      scope: keyword.declaration.type.haskell
      push: type-body
 
  type-body:
    - meta_scope: meta.declaration.type.haskell
    - match: ^(?!\s*(?:--|{-|$))
      pop: 1
    - match: =(?!>)
      scope: keyword.operator.haskell
    - include: big-arrow-operators
    - include: type-content
    - include: else-pop

###[ TYPE SIGNATURES ]#########################################################

  type-signatures:
    # 3 Expressions
    # https://www.haskell.org/onlinereport/haskell2010/haskellch3.html
    - match: '{{operator_double_colon}}'
      scope: keyword.operator.double-colon.haskell
      push: type-signature-body

  type-signature-body:
    # 4.1.2 Syntax of Types
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
    - match: ^(?!\s*(?:--|{-|$))
      pop: 1
    - include: big-arrow-operators
    - include: type-content
    - include: else-pop

  type-content:
    - include: type-forall
    - include: type-lists
    - include: type-tuples
    - include: right-arrow-operators
    - include: ident-anonymous
    - include: ident-namespaces
    - include: ident-types
    - include: ident-variables

  type-forall:
    - match: ∀(?!{{symbol}})
      scope: keyword.operator.forall.haskell
      push: type-forall-body
    - match: forall{{break}}
      scope: keyword.control.forall.haskell
      push: type-forall-body

  type-forall-body:
    - match: \.
      scope: keyword.operator.haskell
      pop: 1
    - include: ident-anonymous
    - include: ident-variables
    - include: else-pop

  type-lists:
    - match: \[
      scope: punctuation.section.sequence.begin.haskell
      push: type-list-body

  type-list-body:
    - meta_scope: meta.sequence.list.haskell
    - include: list-end
    - include: sequence-separators
    - include: type-content
    - include: else-pop

  type-tuples:
    # 4.1.3 Syntax of Class Assertions and Contexts
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-630004.1
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      push: type-tuple-body

  type-tuple-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - include: sequence-separators
    - include: type-content
    - include: else-pop

###[ RECORD CONSTRUCTORS ]#####################################################

  records:
    - match: \{
      scope: punctuation.section.block.begin.haskell
      push: record-body

  record-body:
    - meta_scope: meta.record.haskell meta.block.haskell
    - include: block-end
    - include: expressions
    - include: else-pop

###[ BLOCKS / GROUPS / LISTS / TUPLES ]########################################

  blocks:
    # 2.7 Layout
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
    - match: \{
      scope: punctuation.section.block.begin.haskell
      push: block-body

  block-end:
    - match: \}
      scope: punctuation.section.block.end.haskell
      pop: 1

  block-body:
    - meta_scope: meta.block.haskell
    - include: block-end
    - include: statements
    - include: expressions
    - include: else-pop

  lists:
    # 3.7 Lists
    # https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-340003.7
    - match: \[
      scope: punctuation.section.sequence.begin.haskell
      push: list-body

  list-end:
    - match: \]
      scope: punctuation.section.sequence.end.haskell
      pop: 1

  list-body:
    - meta_scope: meta.sequence.list.haskell
    - include: list-end
    - include: records
    - include: expressions

  groups-or-tuples:
    # 3.8 Tuples
    # https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-360003.8
    # 3.9 Unit Expressions and Parenthesized Expressions
    # https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-380003.9
    - match: (\()\s*(\))
      scope: meta.sequence.tuple.haskell
      captures:
        1: punctuation.section.sequence.begin.haskell
        2: punctuation.section.sequence.end.haskell
    - match: (?=\()
      branch_point: groups-or-tuples
      branch:
        - group
        - tuple

  group:
    - match: \(
      scope: punctuation.section.group.begin.haskell
      set: group-body

  group-end:
    - match: \)
      scope: punctuation.section.group.end.haskell
      pop: 1

  group-body:
    - meta_scope: meta.group.haskell
    - match: ',|:(?!{{symbol}})'
      fail: groups-or-tuples
    - include: group-end
    - include: records
    - include: expressions

  tuple:
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      set: tuple-body

  tuple-end:
    - match: \)
      scope: punctuation.section.sequence.end.haskell
      pop: 1

  tuple-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - include: records
    - include: expressions

  range-tuples:
    - match: (\()(\.\.)(\))
      scope: meta.sequence.tuple.haskell
      captures:
        1: punctuation.section.sequence.begin.haskell
        2: keyword.operator.range.haskell
        3: punctuation.section.sequence.end.haskell

###[ IDENTIFIERS ]#############################################################

  ident-anonymous:
    - match: _{{break}}
      scope: variable.language.anonymous.haskell

  ident-builtin-classes:
    # Prelude Class Types
    - match: '{{builtin_classes}}'
      scope: support.class.prelude.haskell

  ident-builtin-types:
    # Prelude Data Types of special meaning
    - match: '{{builtin_constants}}'
      scope: support.constant.prelude.haskell
    # Prelude Data Types
    - match: '{{builtin_types}}'
      scope: support.type.prelude.haskell

  ident-builtin-functions:
    - match: '{{builtin_functions}}'
      scope: support.function.prelude.haskell

  ident-namespaces:
    - match: ({{con_id}})(\.)
      captures:
        1: variable.namespace.haskell
        2: punctuation.accessor.dot.haskell

  ident-modules:
    - match: '{{con_id}}'
      scope: entity.name.namespace.haskell

  ident-inherited-classes:
    - include: ident-builtin-classes
    - match: '{{con_id}}'
      scope: entity.other.inherited-class.haskell

  ident-inherited-class:
    - match: '{{builtin_classes}}'
      scope: support.class.prelude.haskell
      pop: 1
    - match: '{{builtin_types}}'
      scope: support.type.prelude.haskell
      pop: 1
    - match: '{{con_id}}'
      scope: entity.other.inherited-class.haskell
      pop: 1

  ident-types:
    - include: ident-builtin-classes
    - include: ident-builtin-types
    - match: '{{con_id}}'
      scope: storage.type.haskell

  ident-functions:
    - include: ident-builtin-functions
    - match: '{{var_id}}'
      scope: variable.function.haskell

  ident-variables:
    - match: '{{var_id}}'
      scope: variable.other.haskell

###[ LITERALS ]################################################################

  literal-numbers:
    # 2.5 Numeric Literals
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-190002.5
    - match: \d+(?:(\.)\d+(?:[eE][-+]?\d+)?|[eE][-+]?\d+){{break}}
      scope: meta.number.float.decimal.haskell constant.numeric.value.haskell
      captures:
        1: punctuation.separator.decimal.haskell
    - match: (0[oO])([0-7]+){{break}}
      scope: meta.number.integer.octal.haskell
      captures:
        1: constant.numeric.base.haskell
        2: constant.numeric.value.haskell
    - match: (0[xX])(\h+){{break}}
      scope: meta.number.integer.hexadecimal.haskell
      captures:
        1: constant.numeric.base.haskell
        2: constant.numeric.value.haskell
    - match: \d+{{break}}
      scope: meta.number.integer.decimal.haskell constant.numeric.value.haskell

  literal-chars:
    # 2.6 Character and String Literals
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
    - match: (')(?:([ [\S&&[^\\'']]])|{{escape_sequence}})?(?:(')|{{comment_ahead}})
      scope: meta.string.haskell string.quoted.single.haskell
      captures:
        1: punctuation.definition.string.begin.haskell
        2: constant.character.literal.haskell
        3: constant.character.escape.haskell
        4: constant.character.escape.decimal.haskell
        5: constant.character.escape.octal.haskell
        6: constant.character.escape.hexadecimal.haskell
        7: constant.character.escape.control.haskell
        8: punctuation.definition.string.end.haskell

  literal-strings:
    # 2.6 Character and String Literals
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
    - match: \"
      scope: punctuation.definition.string.begin.haskell
      push: literal-string-body

  literal-string-body:
    - meta_include_prototype: false
    - meta_scope: meta.string.haskell string.quoted.double.haskell
    - match: \"|$
      scope: punctuation.definition.string.end.haskell
      pop: 1
    - match: '{{escape_sequence}}'
      captures:
        1: constant.character.escape.haskell
        2: constant.character.escape.decimal.haskell
        3: constant.character.escape.octal.haskell
        4: constant.character.escape.hexadecimal.haskell
        5: constant.character.escape.control.haskell

###[ KEYWORDS AND OPERATORS ]##################################################

  keywords:
    - match: (?:mdo|do|in|rec|where){{break}}
      scope: keyword.control.context.haskell
    - match: (?:case|of){{break}}
      scope: keyword.control.conditional.select.haskell  # the construct is commonly called "select"
    - match: if{{break}}
      scope: keyword.control.conditional.if.haskell
    - match: then{{break}}
      scope: keyword.control.conditional.then.haskell
    - match: else{{break}}
      scope: keyword.control.conditional.else.haskell
    - match: let{{break}}
      scope: keyword.declaration.variable.haskell
    - match: proc{{break}}
      scope: keyword.declaration.function.haskell

  operators:
    - include: constructor-separators
    - include: sequence-separators
    - include: big-arrow-operators
    - include: left-arrow-operators
    - include: right-arrow-operators
    - include: infix-parens-operators
    - match: (`)[ \w'.]+(`)
      scope: keyword.operator.function.infix.haskell
      captures:
        1: punctuation.definition.function.begin.haskell
        2: punctuation.definition.function.end.haskell
    - match: infix[lr]?{{break}}
      scope: keyword.operator.haskell
    # Match all not otherwise matched single quotes as promoition operator
    # Note: Found in real world code but not in specs so far.
    - match: \'
      scope: keyword.operator.haskell
    - match: '{{operator_symbol}}'
      scope: keyword.operator.haskell

  big-arrow-operators:
    - match: '{{operator_big_arrow}}'
      scope: keyword.operator.big-arrow.haskell

  left-arrow-operators:
    - match: '{{operator_left_arrow}}'
      scope: keyword.operator.arrow.haskell

  right-arrow-operators:
    - match: '{{operator_right_arrow}}'
      scope: keyword.operator.arrow.haskell

  constructor-operators:
    - match: (`)\s*{{con_id}}\s*(`)
      scope: keyword.operator.function.infix.haskell
      captures:
        1: punctuation.definition.function.begin.haskell
        2: punctuation.definition.function.end.haskell
    - match: '{{consym}}|!'
      scope: keyword.operator.haskell

  constructor-separators:
    - match: \|(?!\|)
      scope: punctuation.separator.sequence.haskell

  infix-parens-operators:
    - match: \(\s*({{operator_parens}})\s*\)
      scope: variable.function.infix.haskell
      captures:
        1: keyword.operator.haskell

  statement-terminators:
    # Depending on layout, semicolon may be needed to terminate statements.
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
    - match: ';'
      scope: punctuation.terminator.statement.haskell

  sequence-separators:
    - match: ','
      scope: punctuation.separator.sequence.haskell

  splice:
    - match: '\[(?:|e|d|t|p)\|'
      comment: Points out splices in ast quotes
      scope: keyword.other.quasibracket.haskell
      push:
        - meta_scope: meta.other.quasiquote.haskell
        - match: '(.*)(\|\])'
          captures:
            1: string.quasiquoted.haskell
            2: keyword.other.quasibracket.haskell
          pop: 1
        - match: \$\(
          scope: keyword.other.splice.haskell
        - match: \$
          scope: string.quasiquoted.haskell
        - match: '[^$]*'
          scope: string.quasiquoted.haskell
    - match: \$\(
      comment: Highlight the beginning of a splice.
      scope: keyword.other.splice.haskell
    - match: '\[[\w'']*\|'
      scope: keyword.other.quasibracket.haskell
      push:
        - meta_scope: meta.other.quasiquote.haskell
        - match: '(.*)(\|\])'
          captures:
            1: string.quasiquoted.haskell
            2: keyword.other.quasibracket.haskell
          pop: 1
        - match: .*
          scope: string.quasiquoted.haskell

###[ PROTOTYPES ]##############################################################

  else-pop:
    - match: (?=\S)
      pop: 1

  immediatelly-pop:
    - match: ''
      pop: 1
