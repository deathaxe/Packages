%YAML 1.2
---
# https://www.haskell.org/onlinereport/haskell2010
# https://www.sublimetext.com/docs/syntax.html
name: Haskell
scope: source.haskell
version: 2

file_extensions:
  - hs

###############################################################################

variables:
  # 2.2 Lexical Program Structure
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-160002.2
  special: '[(),;\[\]`{}]'
  symbol: '[\p{S}\p{P}&&[^_"''{{special}}]]'
  ascii_symbol: '[!#$%&â‹†+./<=>?@\\\^|\-~:]'
  unicode_symbol: '[[:punct:]&&[^:ascii:]]'

  # 2.3 Comments
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-170002.3
  no_comment_ahead: '(?!{{comment_begin}})'
  comment_ahead: '(?={{comment_begin}})'
  comment_begin: '--+(?:{{comment_first_char}}|$)'
  comment_first_char: '[\s\w"''{{special}}]'

  # 2.4 Identifiers and Operators
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
  con_id: (?:[[:upper:]][\w']*)
  var_id: (?:(?!{{reserved_id}})[[:lower:]_][\w']*)
  reserved_id: |-
    (?x:
      case | class | data | default | deriving | do | else | foreign | if
    | import | in | infix | infixl | infixr | instance | let | module | newtype
    | of | then | type | where | _
    ){{break}}
  break: (?![\w'])

  # In case this regex seems overly general, note that Haskell permits
  # the definition of new operators which can be nearly any string
  # of punctuation characters, such as $%^&*.
  operator_symbol: (?:{{symbol}}+)
  operator_parens: (?:{{no_comment_ahead}}{{operator_symbol}})

  varsym: (?:[{{symbol}}&&[^:]]{{symbol}}*)
  consym: (?:(?!{{reserved_op}})[:]{{symbol}}*)
  reserved_op: |-
    (?x: .. | :: | : | \\ | \| | <- | -> | @ | ~ | => | = )(?!{{symbol}})

  # 2.6 Character and String Literals
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
  escape_chars: |-
    (?x:
      NUL | SOH | STX | ETX | EOT | ENQ | ACK | BEL | BS | HT | LF | VT | FF
    | CR | SO | SI | DLE | DC1 | DC2 | DC3 | DC4 | NAK | SYN | ETB | CAN | EM
    | SUB | ESC | FS | GS | RS | US | SP | DEL
    | [abfnrtv\\\"'\&]
    )
  escape_sequence: |-
    (?x:
        (\\{{escape_chars}}) # Escapes
      | (\\[0-9]+)           # Decimal Escapes
      | (\\o[0-7]+)          # Octal Escapes
      | (\\x[0-9A-Fa-f]+)    # Hexadecimal Escapes
      | (\^[A-Z@\[\]\\\^_])  # Control Chars
    )

  class_names: |-
    (?x:
      Monad | Monadoid | Functor | Applicative | Foldableble | Traversable | Eq
    | Ord | Read | Show | Num | Fractional | Rational | Enum | Bounded | Real
    | RealFrac | RealFloat | Integral | Floating
    ){{break}}

  function_names: |-
    (?x:
      abs | acos | acosh | all | and | any | appendFile | asTypeOf | asin
    | asinh | atan | atan2 | atanh | break | ceiling | compare | concat
    | concatMap | const | cos | cosh | curry | cycle | decodeFloat | div
    | divMod | drop | dropWhile | either | elem | encodeFloat | enumFrom
    | enumFromThen | enumFromThenTo | enumFromTo | error | errorWithoutStackTrace
    | even | exp | exponent | fail | filter | flip | floatDigits | floatRadix
    | floatRange | floor | fmap | foldMap | foldl | foldl1 | foldr | foldr1
    | fromEnum | fromInteger | fromIntegral | fromRational | fst | gcd | getChar
    | getContents | getLine | head | id | init | interact | ioError
    | isDenormalized | isIEEE | isInfinite | isNaN | isNegativeZero | iterate
    | last | lcm | length | lex | lines | log | logBase | lookup | map | mapM
    | mapM_ | mappend | max | maxBound | maximum | maybe | mconcat | mempty
    | min | minBound | minimum | mod | negate | not | notElem | null | odd | or
    | otherwise | pi | pred | print | product | properFraction | pure | putChar
    | putStr | putStrLn | quot | quotRem | read | readFile | readIO | readList
    | readLn | readParen | reads | readsPrec | realToFrac | recip | rem | repeat
    | replicate | return | reverse | round | scaleFloat | scanl | scanl1 | scanr
    | scanr1 | seq | sequence | sequenceA | sequence_ | show | showChar
    | showList | showParen | showString | shows | showsPrec | significand
    | signum | sin | sinh | snd | span | splitAt | sqrt | subtract | succ | sum
    | tail | take | takeWhile | tan | tanh | toEnum | toInteger | toRational
    | traverse | truncate | uncurry | undefined | unlines | until | unwords
    | unzip | unzip3 | userError | words | writeFile | zip | zip3 | zipWith
    | zipWith3
    ){{break}}

  # https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pragmas
  pragma_keys: |-
    (?x:
      LANGUAGE | OPTIONS_GHC | OPTIONS_HADDOCK | INCLUDE | WARNING | DEPRECATED
    | MINIMAL | UNPACK | NOUNPACK | SOURCE | OVERLAPPING | OVERLAPPABLE
    | OVERLAPS | INCOHERENT | INLINE | NOINLINE | INLINABLE | CONLIKE | LINE
    | RULES | SPECIALIZE | SPECIALISE
    ){{break}}

###############################################################################

contexts:
  prototype:
    - include: comments
    - include: preprocessor-pragmas
    - include: preprocessor-directives

  main:
    - include: statements
    - include: expressions

  statements:
    - include: blocks
    - include: functions
    - include: instances
    - include: classes
    - include: datas
    - include: defaults
    - include: deriving
    - include: types
    - include: imports
    - include: modules
    - include: statement-terminators

  expressions:
    - include: literal-chars
    - include: literal-strings
    - include: literal-numbers
    - include: type-signatures
    - include: operators
    - include: splice
    - include: groups-or-tuples
    - include: lists
    - include: keywords
    - include: ident-builtin-functions
    - include: ident-anonymous
    - include: ident-namespaces
    - include: ident-constants
    - include: ident-variables

###[ COMMENTS ]################################################################

  comments:
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-170002.3
    - include: line-comments
    - include: block-comments

  block-comments:
    - match: \{-(?!#)
      scope: punctuation.definition.comment.begin.haskell
      push: block-comment-body

  block-comment-body:
    - meta_scope: comment.block.haskell
    - match: -\}
      scope: punctuation.definition.comment.end.haskell
      pop: 1
    - match: \{-#
      push: block-comment-nested-body
    - include: block-comments

  block-comment-nested-body:
    - match: -\}
      pop: 1
    - include: block-comments

  line-comments:
    - match: (--+)(?:{{comment_first_char}}.*)?$\n?
      scope: comment.line.double-dash.haskell
      captures:
        1: punctuation.definition.comment.haskell

###[ PREPROCESSOR ]############################################################

  preprocessor-directives:
    # In addition to Haskell's "native" syntax,
    # GHC permits the C preprocessor to be run on a source file.
    - match: ^\s*((#)\s*\w+)
      scope: meta.preprocessor.c
      captures:
        1: keyword.directive.other.c
        2: punctuation.definition.preprocessor.c

  preprocessor-pragmas:
    - match: \{-#
      scope: punctuation.section.preprocessor.begin.haskell
      push: preprocessor-pragma-body

  preprocessor-pragma-body:
    - meta_scope: meta.preprocessor.haskell
    - match: '#-\}'
      scope: punctuation.section.preprocessor.end.haskell
      pop: 1
    - match: '{{pragma_keys}}'
      scope: keyword.directive.other.haskell

###[ MODULE DECLARATIONS ]#####################################################

  modules:
    - match: module{{break}}
      scope: keyword.declaration.namespace.haskell
      push: module-body

  module-body:
    - meta_scope: meta.declaration.module.haskell
    - match: where{{break}}
      scope: keyword.control.context.haskell
      pop: 1
    - match: ({{con_id}})(\.)
      captures:
        1: variable.namespace.haskell
        2: punctuation.accessor.dot.haskell
    - match: '{{con_id}}'
      scope: entity.name.namespace.haskell
    - include: symbols
    - include: else-pop

###[ IMPORT DECLARATIONS ]#####################################################

  imports:
    - match: import{{break}}
      scope: keyword.declaration.import.haskell
      push: import-body

  import-body:
    - meta_scope: meta.import.haskell
    - match: (?:qualified|as|hiding){{break}}
      scope: keyword.declaration.import.haskell
    - match: ({{con_id}})\s*(?:(\.)|(?=\(|as{{break}}))
      captures:
        1: variable.namespace.haskell
        2: punctuation.accessor.dot.haskell
    - match: '{{con_id}}'
      scope: entity.name.namespace.haskell
    - include: symbols
    - include: else-pop

###[ SYMBOL DECLARATIONS ]#####################################################

  symbols:
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      push: symbol-body

  symbol-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - match: module{{break}}
      scope: keyword.declaration.namespace.haskell
    - include: ident-builtin-functions
    - include: ident-functions
    - include: ident-namespaces
    - include: ident-types
    - include: sequence-separators
    - include: infix-parens-operators
    - match: \({{no_comment_ahead}}.*?\)
      comment: So named because I don't know what to call this.
      scope: meta.other.unknown.haskell

###[ CLASS DECLARATIONS ]######################################################

  classes:
    # 4.3.1 Class Declarations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
    - match: class{{break}}
      scope:
        meta.declaration.class.haskell
        keyword.declaration.class.haskell
      branch_point: classes
      branch:
        - class-context
        - class-signature

  class-else-fail:
    - match: (?=\S)
      fail: classes

  class-context:
    # The context specifies the superclasses
    - meta_content_scope: meta.declaration.class.context.haskell
    - match: =>
      scope:
        meta.declaration.class.haskell
        keyword.operator.big-arrow.haskell
      set: class-signature
    - include: class-context-decls
    - include: class-else-fail

  class-context-decls:
    - include: class-context-tuples
    - include: sequence-separators
    - include: ident-anonymous
    - include: ident-namespaces
    - include: ident-types
    - include: ident-generic-types

  class-context-tuples:
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      push: class-context-tuple-body

  class-context-tuple-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - include: class-context-decls
    - include: else-pop

  class-signature:
    - meta_content_scope: meta.declaration.class.signature.haskell
    - match: where{{break}}
      scope: keyword.control.context.haskell
      pop: 1
    - include: type-content
    - include: else-pop

###[ DATA DECLARATIONS ]#######################################################

  datas:
    - match: data{{break}}
      scope:
        meta.declaration.data.haskell
        keyword.declaration.data.haskell
      push: data-body

  data-body:
    - meta_content_scope: meta.declaration.data.haskell
    - match: =
      scope: keyword.operator.haskell
      set: data-constructor
    - include: type-signature-body

  data-constructor:
    - include: records
    - include: else-pop

###[ DEFAULT DECLARATIONS ]####################################################

  defaults:
    # 4.3.4 Ambiguous Types, and Defaults for Overloaded Numeric Operations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
    - match: default{{break}}
      scope: storage.modifier.haskell
      push: default-body

  default-body:
    - meta_scope: meta.declaration.default.haskell
    - include: type-tuples
    - include: else-pop

###[ DERIVING DECLARATIONS ]###################################################

  deriving:
    # 4.3.3 Derived Instances
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
    - match: (?:deriving|via){{break}}
      scope: storage.modifier.haskell
      push: deriving-body

  deriving-body:
    - meta_scope: meta.declaration.deriving.haskell
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      push: deriving-tuple-body
    - include: ident-namespaces
    - include: ident-inherited-class
    - include: else-pop

  deriving-tuple-body:
    - meta_scope: meta.sequence.tuple.haskell
    - match: \)
      scope: punctuation.section.sequence.end.haskell
      pop: 2
    - include: sequence-separators
    - include: ident-namespaces
    - include: ident-inherited-classes

###[ INSTANCE DECLARATIONS ]###################################################

  instances:
    # 4.3.2 Instance Declarations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
    - match: instance{{break}}
      scope: keyword.declaration.instance.haskell
      push: instance-body

  instance-body:
    - meta_scope: meta.declaration.instance.haskell
    - match: where{{break}}
      scope: keyword.control.context.haskell
      pop: 1
    - include: type-signature-body

###[ FUNCTION DECLARATIONS ]###################################################

  functions:
    - match: '^(\s*)({{var_id}}|\(({{operator_parens}})\))\s*(::|âˆ·)'
      captures:
        2: entity.name.function.haskell
        3: keyword.operator.infix.haskell
        4: keyword.operator.double-colon.haskell
      push: function-body

  function-body:
    - meta_scope: meta.function.type-declaration.haskell
    - match: ^(?!\s*(?:--|{-|$)|\1\s)
      pop: 1
    - include: big-arrow-operators
    - include: type-content

###[ TYPE DECLARATIONS ]#######################################################

  types:
    - match: (?:newtype|type){{break}}
      scope: keyword.declaration.type.haskell
      push: type-body

  type-body:
    - meta_scope: meta.declaration.type.haskell
    - include: type-signature-body

###[ TYPE SIGNATURES ]#########################################################

  type-signatures:
    # 3 Expressions
    # https://www.haskell.org/onlinereport/haskell2010/haskellch3.html
    - match: '::'
      scope: keyword.operator.double-colon.haskell
      push: type-signature-body

  type-signature-body:
    # 4.1.2 Syntax of Types
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
    - match: ^(?!\s*(?:--|{-|$))
      pop: 1
    - include: big-arrow-operators
    - include: type-content
    - include: else-pop

  type-content:
    - include: type-lists
    - include: type-tuples
    - include: arrow-operators
    - include: sequence-separators
    - include: ident-namespaces
    - include: ident-types
    - include: ident-anonymous
    - include: ident-generic-types

  type-lists:
    - match: \[
      scope: punctuation.section.sequence.begin.haskell
      push: type-list-body

  type-list-body:
    - meta_scope: meta.sequence.list.haskell
    - include: list-end
    - include: type-content

  type-tuples:
    # 4.1.3 Syntax of Class Assertions and Contexts
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-630004.1
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      push: type-tuple-body

  type-tuple-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - include: type-content

###[ RECORD COSTRUCTORS ]######################################################

  records:
    - match: ({{con_id}})\s*(\{)
      captures:
        1: storage.type.haskell
        2: meta.block.haskell punctuation.section.block.begin.haskell
      set: record-body

  record-body:
    - meta_scope: meta.record.haskell
    - meta_content_scope: meta.block.haskell
    - match: \}
      scope: meta.block.haskell punctuation.section.block.end.haskell
      pop: 1
    - include: expressions

###[ BLOCKS / GROUPS / LISTS / TUPLES ]########################################

  blocks:
    # 2.7 Layout
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
    - match: \{
      scope: punctuation.section.block.begin.haskell
      push: block-body

  block-end:
    - match: \}
      scope: punctuation.section.block.end.haskell
      pop: 1

  block-body:
    - meta_scope: meta.block.haskell
    - include: block-end
    - include: main

  lists:
    # 3.7 Lists
    # https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-340003.7
    - match: \[
      scope: punctuation.section.sequence.begin.haskell
      push: list-body

  list-end:
    - match: \]
      scope: punctuation.section.sequence.end.haskell
      pop: 1

  list-body:
    - meta_scope: meta.sequence.list.haskell
    - include: list-end
    - include: expressions

  groups-or-tuples:
    # 3.8 Tuples
    # https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-360003.8
    # 3.9 Unit Expressions and Parenthesized Expressions
    # https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-380003.9
    - match: (\()\s*(\))
      scope: meta.sequence.tuple.haskell
      captures:
        1: punctuation.section.sequence.begin.haskell
        2: punctuation.section.sequence.end.haskell
    - match: (?=\()
      branch_point: groups-or-tuples
      branch:
        - group
        - tuple

  group:
    - match: \(
      scope: punctuation.section.group.begin.haskell
      set: group-body

  group-end:
    - match: \)
      scope: punctuation.section.group.end.haskell
      pop: 1

  group-body:
    - meta_scope: meta.group.haskell
    - match: ',|:(?!{{symbol}})'
      fail: groups-or-tuples
    - include: group-end
    - include: expressions

  tuple:
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      set: tuple-body

  tuple-end:
    - match: \)
      scope: punctuation.section.sequence.end.haskell
      pop: 1

  tuple-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - include: expressions

###[ IDENTIFIERS ]#############################################################

  ident-builtin-classes:
    - match: '{{class_names}}'
      scope: support.class.prelude.haskell

  ident-inherited-classes:
    - include: ident-builtin-classes
    - match: '{{con_id}}'
      scope: entity.other.inherited-class.haskell

  ident-inherited-class:
    - match: '{{class_names}}'
      scope: support.class.prelude.haskell
      pop: 1
    - match: '{{con_id}}'
      scope: entity.other.inherited-class.haskell
      pop: 1

  ident-generic-types:
    - match: '{{var_id}}'
      scope: variable.other.generic-type.haskell

  ident-namespaces:
    - match: ({{con_id}})(\.)
      captures:
        1: variable.namespace.haskell
        2: punctuation.accessor.dot.haskell

  ident-types:
    - include: ident-builtin-classes
    - match: '{{con_id}}'
      scope: storage.type.haskell

  ident-constants:
    - match: '{{con_id}}'
      scope: constant.other.haskell

  ident-builtin-functions:
    - match: '{{function_names}}'
      scope: support.function.prelude.haskell

  ident-functions:
    - match: '{{var_id}}'
      scope: variable.function.haskell

  ident-anonymous:
    - match: _{{break}}
      scope: variable.language.anonymous.haskell

  ident-variables:
    - match: '{{var_id}}'
      scope: meta.name.haskell

###[ LITERALS ]################################################################

  literal-numbers:
    # 2.5 Numeric Literals
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-190002.5
    - match: \d+(?:(\.)\d+(?:[eE][-+]?\d+)?|[eE][-+]?\d+){{break}}
      scope: meta.number.float.decimal.haskell constant.numeric.value.haskell
      captures:
        1: punctuation.separator.decimal.haskell
    - match: (0[oO])([0-7]+){{break}}
      scope: meta.number.integer.octal.haskell
      captures:
        1: constant.numeric.base.haskell
        2: constant.numeric.value.haskell
    - match: (0[xX])(\h+){{break}}
      scope: meta.number.integer.hexadecimal.haskell
      captures:
        1: constant.numeric.base.haskell
        2: constant.numeric.value.haskell
    - match: \d+{{break}}
      scope: meta.number.integer.decimal.haskell constant.numeric.value.haskell

  literal-chars:
    # 2.6 Character and String Literals
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
    - match: (')(?:([ [\S&&[^\\'']]])|{{escape_sequence}})?(?:(')|{{comment_ahead}})
      scope: meta.string.haskell string.quoted.single.haskell
      captures:
        1: punctuation.definition.string.begin.haskell
        2: constant.character.literal.haskell
        3: constant.character.escape.haskell
        4: constant.character.escape.decimal.haskell
        5: constant.character.escape.octal.haskell
        6: constant.character.escape.hexadecimal.haskell
        7: constant.character.escape.control.haskell
        8: punctuation.definition.string.end.haskell

  literal-strings:
    # 2.6 Character and String Literals
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
    - match: \"
      scope: punctuation.definition.string.begin.haskell
      push: literal-string-body

  literal-string-body:
    - meta_include_prototype: false
    - meta_scope: meta.string.haskell string.quoted.double.haskell
    - match: \"|$|{{comment_ahead}}
      scope: punctuation.definition.string.end.haskell
      pop: 1
    - match: '{{escape_sequence}}'
      captures:
        1: constant.character.escape.haskell
        2: constant.character.escape.decimal.haskell
        3: constant.character.escape.octal.haskell
        4: constant.character.escape.hexadecimal.haskell
        5: constant.character.escape.control.haskell

###[ KEYWORDS AND OPERATORS ]##################################################

  keywords:
    - match: let{{break}}
      scope: keyword.declaration.variable.haskell
    - match: (?:do|in|where){{break}}
      scope: keyword.control.context.haskell
    - match: (?:case|of){{break}}
      scope: keyword.control.conditional.select.haskell  # the construct is commonly called "select"
    - match: if{{break}}
      scope: keyword.control.conditional.if.haskell
    - match: then{{break}}
      scope: keyword.control.conditional.then.haskell
    - match: else{{break}}
      scope: keyword.control.conditional.else.haskell
    - match: otherwise{{break}}
      scope: keyword.control.conditional.otherwise.haskell
    - match: return{{break}}
      scope: keyword.control.flow.return.haskell

  operators:
    - include: infix-parens-operators
    - include: sequence-separators
    - match: (`)[ \w'.]+(`)
      # Haskell allows any ordinary function application (elem 4 [1..10])
      # to be rewritten as an infix expression (4 `elem` [1..10])."
      scope: keyword.operator.function.infix.haskell
      captures:
        1: punctuation.definition.function.begin.haskell
        2: punctuation.definition.function.end.haskell
    - match: infix[lr]?{{break}}
      scope: keyword.operator.haskell
    # Match all not otherwise matched single quotes as promoition operator
    # Note: Found in real world code but not in specs so far.
    - match: \'
      scope: keyword.operator.haskell
    - match: '{{operator_symbol}}'
      scope: keyword.operator.haskell

  arrow-operators:
    - match: (?:->|â†’)
      scope: keyword.operator.arrow.haskell

  big-arrow-operators:
    - match: (?:=>|â‡’)
      scope: keyword.operator.big-arrow.haskell

  infix-parens-operators:
    - match: \(\s*({{operator_parens}})\s*\)
      scope: variable.function.infix.haskell
      captures:
        1: keyword.operator.haskell

  statement-terminators:
    # Depending on layout, semicolon may be needed to terminate statements.
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
    - match: ';'
      scope: punctuation.terminator.statement.haskell

  sequence-separators:
    - match: ','
      scope: punctuation.separator.sequence.haskell

  splice:
    - match: '\[(?:|e|d|t|p)\|'
      comment: Points out splices in ast quotes
      scope: keyword.other.quasibracket.haskell
      push:
        - meta_scope: meta.other.quasiquote.haskell
        - match: '(.*)(\|\])'
          captures:
            1: string.quasiquoted.haskell
            2: keyword.other.quasibracket.haskell
          pop: 1
        - match: \$\(
          scope: keyword.other.splice.haskell
        - match: \$
          scope: string.quasiquoted.haskell
        - match: '[^$]*'
          scope: string.quasiquoted.haskell
    - match: \$\(
      comment: Highlight the beginning of a splice.
      scope: keyword.other.splice.haskell
    - match: '\[[\w'']*\|'
      scope: keyword.other.quasibracket.haskell
      push:
        - meta_scope: meta.other.quasiquote.haskell
        - match: '(.*)(\|\])'
          captures:
            1: string.quasiquoted.haskell
            2: keyword.other.quasibracket.haskell
          pop: 1
        - match: .*
          scope: string.quasiquoted.haskell

###[ PROTOTYPES ]##############################################################

  else-pop:
    - match: (?=\S)
      pop: 1
